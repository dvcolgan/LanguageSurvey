http://stackoverflow.com/questions/1012573/how-to-learn-haskell
http://learnyouahaskell.com/chapters
http://haskell.org/haskellwiki/H-99%3a_Ninety-Nine_Haskell_Problems
http://www.haskell.org/haskellwiki/Tutorials#Using_monads
http://www.haskell.org/all_about_monads/html/index.html
http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/
http://channel9vip.orcsweb.com/shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads/
http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
http://stackoverflow.com/questions/44965/what-is-a-monad
http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
http://stackoverflow.com/questions/2488646/why-are-side-effects-modeled-as-monads-in-haskell
http://www.haskell.org/tutorial/
http://stackoverflow.com/questions/3063652/whats-the-status-of-multicore-programming-in-haskell
http://stackoverflow.com/questions/3120796/haskell-testing-workflow
freenode #haskell

learn you a haskell for great good

has referential transparency
shorter programs have fewer bugs and are easier to maintain because there is less code
precedence issues are fun, I think I get them now
haskell is MUCH faster to startup than Clojure

http://projects.haskell.org/haskellmode-vim/
http://www.vim.org/scripts/script.php?script_id=3034

if statement is an expression not a statement, and returns a value
list processing similar to lisp - [], ++, : (cons operator) 1:2:3:[], !!
head, tail, last, init, length, null, reverse, take, drop, maximum, minimum, sum, product, elem
[1..20] [1,3..20] [20,19..1]
laziness -> take 100 [10,20..]
cycle, repeat, replicate
[x*2 | x <- [1..10]]
[x*2 | x <- [1..10], x*2 >= 12]
boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
with multiple inputs, the first changes the least often
use tuples when you know how many elements and need them to be different types
fst, snd, zip

Of all the triangles with sides <= 10 have a perimeter of 24?
per24 = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
:t -> examine type in interactive mode

types: Int, Integer, Float, Double, Bool, Char

polymorphic functions - can operate on any type

typeclasses - types that implement the typeclass supports the behavior described
common typeclasses: Eq, Ord, Show, Read, Enum, Bounded, Integral, Floating

show 3 returns "3"
read "3" returns 3

numbers are polymorphic constants, because they can be Int, Integer, Float, Double, etc

pattern matching is awesome
add a catchall pattern at the end

as patterns - all@(x:xs)

guards - like big if/else trees, use for GA

let
case

"you do computation in Haskell by declaring what something is instead of declaring how you get it.

error function to error out

infinite recursion can be used to create infinite lists

space is an operator (function application) and has highest precedence

currying

byTen = (* 10)

zipWith, flip, map, takeWhile

map and filter lists to do processing, using laziness to help

lambdas: \x -> x*x
can take any number of arguments, but can't have multiple pattern matching sections

foldl takes a list and reduces it starting on the left side
sum = foldl (+) 0

$ - lowest precedence, applies the right side as an argument to the function on the left
can map the concept of function application
map ($ 3) [(4+), (10*), (^2), sqrt]

. - function composition, can be used to must two functions together for map or folds

point free style - don't pass parameters, just define a function
fn x = ceiling (negate (tan (cos (max 50 x)))) 
becomes
fn = ceiling . negate . tan . cos . max 50
point free style is discouraged because it can lead to code that is hard to read, similar to J code it seems


99 haskell problems


http://www.haskell.org/ghc/docs/latest/html/libraries/
http://haskell.org/hoogle

Data.List - prelude imports some by default

intersperse, intercalate, transpose

foldl', foldl1' - strict versions, don't overflow the stack as readily

Algebraic data types
data Bool = False | True
data Shape = Circle Float Float Float | Rectangle Float Float Float Float

parts after = are value constructors - a function that returns a value of that type

polymorphic typeclasses - similar to clojure's protocols

can be used anywhere a function can map (Circle 10 20) [4,5,6]

can not export value constructors to only allow importing modules to use auxiliary functions to manipulate the types

record syntax lets you name type contructor parameters
types can take parameters for more polymorphic fun

make types as generic as they need to be, but no more

type constructor is before =, value constructor is after

type classes are more like interfaces in Java, and can derive the behavior of other classes

Ord uses the order of the value constructors to determine order

can make type synonyms with the 'type' keyword
type PhoneBook = [(String,String)]

can use the Either type, Left is an error and Right is a right value

 recursive data structures

 create your own operators with infixr|l, set their precedence, 
 pattern matching matches on constructors

binary search tree - insert returns a new tree with the element added, laziness and optimizations make this fast enough

:info
id function - takes a parameter and returns it

Functor - type class of things that can be mapped over
class Functor f where fmap :: (a -> b) -> f a -> f b
f is a typeclass that takes a parameter
can instance class Functor over any container - lists, Maybe, binary tree, and define how to iterate over it

types have types called kinds, :k to look at the type, types can be curried and partially applied

hello world does not come until chapter 9

"printStrLn returns an IO action that has a result type of ()"

name = getLine means assign name an IO action
name <- getLine extracts the value from getLine
IO actions are only performed inside main or an IO block

conditional branches have to both have the same type

return takes a value and makes it an IO value
return is the opposite of <-

lazy IO - getContents reads when it needs to, useful for piping

interact - take user input and run it through a function and output result

file IOMode - enumerations made easy
lazy file IO - open the whole file with hGetContents, but it is not all loaded into memory

dispatch association list - string -> function tuple list

random numbers - give a seed and returns a value and a new random seed, so it is purely functional still

take 10 $ randomRs ('a', 'z') (mkStdGen 3) :: [Char] - because of the amazing type system, you can do things like this - a range of characters for the random function to generate random strings - there are many more ways to combine things in Haskell

bitestrings - less lazy for better performance with maybe higher memory usage

exceptions can only be handled in pure code, because lazy code doesn't know when it will be evaluated
don't use exceptions in pure code
catch function is similar to try catch blocks

fmap - apply a function to an IO action
main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
          putStrLn line

functions are functors ((->) r)

fmap on a function is just function composition - doing fmap on a function takes that function out of the box and modifies it and puts it back into the box

functor laws

functor - fmap (*) Just 3 == Just ((*) 3)

can use <$> and <*> to map a function over functors

newtype - make a synonym for a type when you want to make it a part of different type classes

"A monoid is when you have an associative binary function and a value which acts as an identity with respect to that function."

monads take a function with a context, extract the value, and feed it into a function that takes a value and returns a value with a context

do notation can be used for other things than IO

list comprehensions are syntactic sugar for >>= and list monads



http://upload.wikimedia.org/wikipedia/commons/a/aa/Write_Yourself_a_Scheme_in_48_Hours.pdf


for a complicated language like haskell, reading different tutorials at different times and repeatedly helps a lot.  Forgetting and relearning a difficult topic makes it seem easier the second time

also, these languages all have many things in common, and seeing it implemented in other languages is also helpful for learning

I want to teach this language to other people by showing how we can take complicated code and make it increasingly shorter and more elegant.  (I love elegant things.)

it does seem to be difficult to really write idiomatic code in an objective way when just learning the language, especially haskell

!Taking notes as I do things is also very important I'm finding; otherwise I just forget things.

I wonder how it would have been different had I done the project first in Haskell and then the other languages?  How much of the Python style is influencing how I do this?



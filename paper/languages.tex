\documentclass{article}
\usepackage{url}
\title{An Investigation of Lesser Known Programming Languages}
\author{David Colgan}
\date{\today}
\begin{document}
\maketitle

\section{Introduction}

Most computer science majors and software developers have used Java and C.
According to the TIOBE Index~\cite{tiobe}, these two languages have
consistently been among the most popular for general use.  They are both
established, well understood, and use the object oriented or imperative
paradigm.

Most of the other top languages are fairly similar to Java and C.  Languages
like C\#, PHP, Python, Perl, and Objective-C all use some combination of the
procedural and object-oriented paradigm.   But are procedural and object
oriented languages the best computer science has to offer for creating
reliable, high performing software on a budget?

Many lesser-known languages influenced by the functional paradigm claim
increased programmer productivity, fewer errors, shorter programs, and greatly
enhanced support for multicore processing.

\section{Research Goals}

This project seeks to investigate languages that have the potential to be
compelling alternatives to the common procedural and object oriented languages
most often used today in commercial environments.  I want to know if they live
up to the hype generated by their communities.

In the two semesters of this project I investigated three lesser-known languages
and two more common languages to serve as a comparison.  The two common
languages are C and Python, and the three lesser-known languages are Clojure,
Haskell, and Factor.  

\section{Literature Survey of Previous Work}
\label{sec:survey}

Two kinds of research in the literature compare programming languages:
feature-by-feature comparisons and comparisons of small programs.

\subsection{Feature Comparisons}

Feuer and Gehani~\cite{FeuerCVsPascal} take a conceptual approach when they compare C and
Pascal.  They begin with a history of the languages and
discuss design decisions, followed by a step-by-step walk through each
language's major features.  They also evaluate C and Pascal for different
problem domains.  This paper is more of an informative overview than a hard
empirical evaluation.  The only actual code they show is a single function
implementing binary search.

In a comparison of Ada 95 and Java, Brosgol~\cite{BrosgolCompOOAdaVsJava} takes
a similar approach, going feature by feature through the two languages.  He
provides sample code snippets throughout.  He arrives at a table of features,
highlighting differences in syntax, program organization features, memory
management, and OO features like inheritance, polymorphism, and encapsulation.

Nami~\cite{NamiCompOOSoftEng} presents a factual comparison of Eiffel, C++, Java, and
Smalltalk.  He gives a brief introduction to each
language, describing design decisions and history.  He then classifies each
language based on static vs\. dynamic typing, compiled vs\. interpreted build
methods, built-in quality assurance facilities, automatic documentation
generators, multiple vs\. single inheritance, and concludes with a brief
discussion on each language's efficacy for building infrastructures.

Tang~\cite{TangAdaVsCpp} does a similar comparison of Ada and C++ using many of
the same methods as the other studies.

Many of these studies are a high level overview of various languages.  They
compare features, but do not give in-depth examples.

\subsection{Program Comparisons}

Perhaps more useful and interesting are those comparisons done by inspecting
the same program written in different languages.  These give concrete examples
of the differences.

The method I follow for this project is closely related to the method used by
Prechelt~\cite{Prechelt7LangComp}.  He compares C, C++, Java, Perl, Python,
Rexx, and Tcl by having various computer science masters students and
volunteers from newsgroups write the same small program in one of the
languages.  He then compared the resulting programs based on program runtime,
memory consumption, lines of code, program reliability (based on whether the
program crashes or not), the amount of time it took each programmer to write
the program, and program structure.  The program he had the participants write
was a simple string processing program that consisted of converting telephone
numbers into sentences based on a large dictionary and mapping scheme.  Most of
the programs he received were fairly small, taking a median of 3.1 hours to
write, and averaging 200-300 line of code.

Some of the more interesting results from Prechelt's study include the
observation that in lower-level languages, a lot of code is dedicated to
writing the data structures, while the higher-level languages, the programmer
usually takes advantage of the language's built-in capabilities.  He also found
that the scripting languages (Perl, Python, Rexx, and Tcl) tend to require
about twice as much memory as C and C++, with Java taking 3--4 times as much,
and that C and C++ are about twice as fast as Java and several times faster
still than scripting languages.

Prechelt discusses the validity of his evaluations.  He acknowledges the
potential problems of asking for self-reported data from the Internet, as well
as potential differences in programmer ability and working conditions.  He
suggests that because 80 programmers contributed code, this large sample size
balances out many of these problems.  Though the results should not be trusted
for small differences, he asserts that large differences are likely to be
accurate.

Henderson and Zorn~\cite{Henderson4OOLangComp} perform a similar study.  They
compare C++, a well known language, with four lesser-known languages: Oberon-2,
Modula-3, Sather, and Self.  They also write a short program in each of the
languages, a simple database for university personnel information.  These are
all object-oriented languages, and as such, the comparison is weighted
specifically towards OO features.  They compare each language's methods of
implementing and capabilities for inheritance, dynamic dispatch, code reuse,
and information hiding.  In addition to OO features, they also compare
execution time, lines of code, and compile time.  Henderson and Zorn explicitly
state that one of the goals of their survey is to increase programmer awareness
of lesser-known languages.

In a less formal study, Floyd~\cite{DDJFloydeCompOOLangs} compares C++,
Smalltalk, Eiffel, Sather, Objective-C, Parasol, Beta, Turbo Pascal, C+@,
Liana, Ada, and, Drool.  He collects an implementation of a linked-list
structure from various people and then summarizes the results in a table that
compares garbage collection schemes, inheritance (single or multiple), binding
time, compilation (compiled vs\. interpreted), exception handling features, and
lines of code.  He simply enumerates the implementations and does not do
further analysis.

\section{My Work}

I combine the two approaches discussed in section~\ref{sec:survey}.  The
deliverables for my project, like Prechelt, include implementations of the same
program in multiple languages. I also include high level feature comparisons
among the languages.

The primary way I compare the languages is by writing the same program in each
language.  I also chose to write a system that is more complicated than that of Prechelt,
as I felt the program he (and many of the others) used to compare the languages
lacked substance.

One day at family game night we played a dice game called
Farkle~\cite{farklewikipedia}.  The game is simple but has a fair amount of
decision making.  Therefore for each language I implement a system that plays
this dice game through a command line interface.  Such a system involves many
different aspects that explore each language's potential and features.  For an
overview of the rules of Farkle, see section~\ref{sec:farklerules}.

\subsection{Methodology}

I first implemented the Farkle system in Python, the language I know
best, to serve as a basis for comparison.  I then rewrote the system in Clojure.
Clojure is a language I have not had experience with, although I have used other
\textsc{Lisp} dialects.  In my past experience with other \textsc{Lisp}s, I did not
fully understand or apply the functional style.  Next I wrote the system in
Haskell, a purely functional language that is even more so than Clojure.  I
then took a respite and wrote the system in C, another language I know well, to
give another standard of comparison.  I finished out with an implementation in
Factor, a relatively unknown language with a very different way of doing things.

Having completed the system in all five of these languages, I ran performance
tests by timing how long each language takes to have four simplistic AI players
compete 10000 games.

I also wrote a short Python script to compare the number of lines, number of
tokens, average line length, and average tokens per line of each program, where
a token is any whitespace-separated block of characters.

I also recorded observations made as I programmed each system.  In the following
sections, I will outline my findings for each.

\subsection{Python}

Since I already knew Python, there was no major learning involved in its
implementation.  It came in at around 900 lines of code excluding tests, and
there are libraries available for concurrency, but the programmer must add it
manually.

As I implement the system in other languages, I have noticed instances where I
could have made the Python implementation shorter.  Therefore the 900 lines
could be reduced; Python had the disadvantage of going first.

I consider the Python implementation to be the standard for comparison.  I give
it a ``normal'' difficulty in terms of learning, shortness of programs, and
concurrency.

\subsection{Clojure}

\subsection{Learning Clojure}

To begin the process of learning Clojure, I read the book \underline{Programming
Clojure} by Stuart Halloway~\cite{clojurebook}.  After going through this book,
I was a bit underwhelmed by my level of understanding.  I got the basics, but I
still didn't feel ready to begin implementing the Farkle system.  A few of the
other resources I used included a very well-written Clojure tutorial by R\. Mark
Volkmann~\cite{clojuretutorial}, the official Clojure
website~\cite{clojuredotorg}, the PeepCode screencast on
Clojure~\cite{peepcodeclojure}, the very helpful community question and answer
site Stack Overflow~\cite{stackoverflow}, and other pages found through Google.

\subsection{Comparison of Lines of Code}

The Clojure code weighs in at approximately 700 lines.  This is a fair
difference from the Python implementation, though it is more lines than I
expected.

\subsection{Ease of Learning}

For those coming from a mostly procedural and object-oriented background,
Clojure will definitely be a stretch.  The most striking difference is the new
functional paradigm.  Clojure is not purely functional, allowing side effects
like printing to the screen anywhere in the code.  However, once a variable has
been given a value, its value cannot be changed.  All procedural programming
involves changing state, so those without a functional background will have to
completely adjust their thinking.  Idiomatic Clojure makes heavy use of
recursion and higher order functions.  It should be noted, though, that because
Clojure discourages side effects, unit testing is much easier.

Another major difference is Clojure's laziness.  It does not evaluate
expressions unless it has to, causing great speedups in some cases, and allowing
for infinite data structures.  This is a powerful feature, but it takes some
getting used to.  

The syntax of Clojure is also very different than most other languages.  Its
syntax of parentheses and brackets allows for powerful macros, but it is
definitely not C-like, so programmers who have never seen syntax like this will
have to make an adjustment.

Therefore, Clojure has three new major concepts to learn: the functional
paradigm, laziness, and the new style of syntax.

\subsection{Support for Concurrency}

Clojure has excellent support for parallel processing.  In the simplest case, a
program can be made to perform parallel computations by replacing a call to
\texttt{map} with a call to \texttt{pmap}.  The \texttt{pmap} function has a
larger overhead than \texttt{map}, so it is not effective for simple
calculations.  However, if processing one element of the list using
\texttt{pmap} is free of side effects and computationally intensive, Clojure can
utilize multiple cores automatically.  This is much simpler than using a manual
thread-based approach that one would need in Python, Java, C.

Note that this only works if the calculations pmap does are free from side
effects and if each part of the calculation are independent.  If the program
needs to share state between threads or cores, Clojure has an extensive system
known as Software Transactional Memory.  Clojure implements a system similar to
a database transaction that allows for easily sharing state in a thread-safe
manner.  I did not have to use this more complicated system, though, because
the major calculation I performed were in the GA system, and the process of
evaluating and crossing over individuals is self contained and does not depend
on any other individuals.  Therefore my program got free multicore support
using \texttt{pmap}.

\subsection{Disadvantages of Clojure}

Clojure is plagued by a few problems.  One of the aspects of the language that
is both a blessing and a curse is its close integration with Java.  While this
is good in that it can use Java libraries, it also inherits many of Java's
problems.  Clojure is not a very good language for scripts or anything that
requires fast startup.  Starting any Clojure program cold takes on the order of
10 seconds.  For this reason, the developers recommend starting one running
Clojure repl and continuously send commands to it.  This mostly works, but I
found myself having to start new instances more than was comfortable through the
process of programming.

The second major problem with Clojure is its youth.  The language is only
a few years old, and it is rapidly evolving and getting better.  However, even
some core features of the language have been implemented just this year, such as
protocols.

A bigger problem is that because the language is so young, the tools are not
very mature either.  Slime, the flagship editing environment for all kinds of
\textsc{Lisp}s built on Emacs does not support Clojure nearly as well as the more mature
\textsc{Lisp}s.  A case in point is that the \texttt{read-line} function, the primary way of
getting command line input, simply doesn't work in Slime.  This created a
problem for my command line program.  The Slime debugger is also not very
helpful when working with Clojure.  Stack traces show 100 levels of Java
method calls and a single location in my code where the error occured.

There is a system developed to write Clojure in Vim called VimClojure, but I
could not figure out how to install it completely.  After spending multiple
hours on it, I eventually went back to Emacs.

There are also Eclipse and Netbeans plugins that I did not investigate.

\begin{table}[h]
    \caption{Summary of Language Features}
    \begin{tabular}{|p{1.6in}|p{1.6in}|p{1.6in}|}
        \hline
        Aspect & Python & Clojure \\
        \hline
        Ease of Learning    & Easy & Hard \\
        \hline
        Ease of Programming & Easy & Hard \\
        \hline
        Approximate Line of Code & 900 & 700 \\
        \hline
        Support for Concurrency & Manual Threading & Automatic with \texttt{pmap}, Software Transactional Memory \\
        \hline
        Purity              & Impure & Pure by default \\
        \hline
        Supported Paradigms & Procedural, Object Oriented, Functional & Functional, Object Oriented \\
        \hline
        Evaluation Strategy & Eager & Lazy \\
        \hline
        Execution Method    & Interpreted & Byte-code Compiled \\
        \hline
    \end{tabular}
\end{table}

\begin{table}[h]
    \caption{Summary of Language Features}
    \begin{tabular}{|p{1.6in}|p{1.6in}|p{1.6in}|}
        \hline
        Aspect & Python & Clojure \\
        \hline
        Ease of Learning    & Easy & Hard \\
        \hline
        Ease of Programming & Easy & Hard \\
        \hline
        Approximate Line of Code & 900 & 700 \\
        \hline
        Support for Concurrency & Manual Threading & Automatic with \texttt{pmap}, Software Transactional Memory \\
        \hline
        Purity              & Impure & Pure by default \\
        \hline
        Supported Paradigms & Procedural, Object Oriented, Functional & Functional, Object Oriented \\
        \hline
        Evaluation Strategy & Eager & Lazy \\
        \hline
        Execution Method    & Interpreted & Byte-code Compiled \\
        \hline
    \end{tabular}
\end{table}


\section{Conclusions}

I was expecting a larger difference in the number of lines of code between
Python and Clojure.  One of the thing that the functional programming advocates
push is how much shorter functional programs are than non-functional ones.  The
Clojure program was shorter in some parts, but in other parts it was almost the
same size.  I do expect that the C and Java implementations will be much longer
than the Python implementation.  Python, although not overly functional, is a very
expressive language.  I will be interested to see how many lines the Haskell
implementation has.

Purely functional programs are much easier to test than those with side effects.
I am very confident in the Clojure code that I wrote, and this experience
encourages me to write in a style that uses as few side effects as possible
even in procedural and object-oriented languages.

With concurrency being as easy to tack on as it is in Clojure, this makes me
reluctant to try to ever implement a manually concurrent program in a language
like Python.  Since a language like Clojure can automatically parallelize my
programs, if I ever need multicore support, I will be much more inclined to
switch languages for that project.

\section{Plans for Future Work}

I wrote programs in as many languages as I had time for, and ended up completing
five.  In the future I would also like to have programs completed in Java,
Erlang, and J.  I would also be interested in seeing implementations in Scala,
F\#, O'Caml, Lua, and Groovy.  The more languages in the comparison, the more
useful and informative it will be.

One of the greatest flaws of my project is the fact that I was the only one
writing programs for comparison.  As such, my sample size is one.  I would love
to in the future enlist the skills of prominent community members in each of
these languages and ask them to write a Farkle program.  Since I was just
learning some of these languages, my implementation may be much slower and
longer than what a master would produce.  I know that I did not make use of all
the advanced features of every language.  It would also be better if there were
more than one of each program.

It might be interesting for me to come back to this project in a few years after
I myself have matured more as a programmer.  I have been trying to learn the
functional paradigm for several years now, and while I am getting better, I am
nowhere near fluent.  As I said above, learning a new language is easy, but
learning a new paradigm is hard.

\bibliographystyle{plain}
\bibliography{languages}

\appendix
\section{Farkle Rules}
\label{sec:farklerules}

Farkle requires six dice.  On each turn, the player rolls all six dice and
removes combinations that are worth points.  The following combinations are
worth points:

\begin{itemize}
\item One 5 - 50 points
\item One 1 - 100 points
\item Three 1s - 300 points
\item Three 2s - 200 points
\item Three 3s - 300 points
\item Three 4s - 400 points
\item Three 5s - 500 points
\item Three 6s - 600 points
\item Four of a kind - 1000 points
\item 1-6 Straight   - 1500 points
\item Three pairs    - 1500 points
\item Five of a kind - 2000 points
\item Two triples    - 2500 points
\item Six of a kind  - 3000 points
\end{itemize}

To score, the combination must be removed all on the same turn.  As long as the
player can remove at least one die that scores, they can then continue rolling.
If the player cannot remove at least one die, they ``Farkle'' and lose all
points for that turn.  The strategy in the game comes from knowing when to stop
rolling and which dice to set aside.

\end{document}
